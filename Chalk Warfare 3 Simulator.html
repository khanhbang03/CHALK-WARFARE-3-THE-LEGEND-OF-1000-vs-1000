<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chalk Warfare 3 — 1000 vs 1000 Simulator</title>
<style>
  :root{--bg:#071226;--panel:#0d1a2a;--red:#e06464;--blue:#63a6ff;--muted:#9fb0c2}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(180deg,var(--bg),#04121b);color:#e6eef6}
  #wrap{display:flex;gap:12px;padding:12px;box-sizing:border-box;height:100vh}
  #left{width:360px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:14px}
  #center{flex:1;display:flex;flex-direction:column}
  canvas{background:#071827;border-radius:10px;display:block}
  h1{font-size:18px;margin:6px 0}
  .panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-bottom:10px}
  button{background:#0f2436;color:#e6eef6;border:0;padding:8px 10px;border-radius:8px;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .statRow{display:flex;justify-content:space-between;align-items:center;padding:6px 0}
  .big{font-weight:700;font-size:20px}
  .ability{display:flex;gap:8px;align-items:center}
  .ability button{padding:10px}
  .footer{font-size:12px;color:var(--muted);margin-top:8px}
</style>
</head>
<body>
<div id="wrap">
  <div id="left">
    <h1>Chalk Warfare 3 — Simulator</h1>
    <div class="panel">
      <div class="statRow"><div class="muted">Match</div><div class="big">1000 Hoang Thai Son vs 1000 Hoang Thu Trang</div></div>
      <div class="statRow"><div class="muted">Time</div><div id="time">00:00</div></div>
      <div class="statRow"><div class="muted">Red Alive</div><div id="redAlive">1000</div></div>
      <div class="statRow"><div class="muted">Blue Alive</div><div id="blueAlive">1000</div></div>
      <div class="statRow"><div class="muted">Red Kills</div><div id="redKills">0</div></div>
      <div class="statRow"><div class="muted">Blue Kills</div><div id="blueKills">0</div></div>
    </div>

    <div class="panel">
      <div class="muted">Controls</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <div class="muted">Speed</div>
        <input id="speed" type="range" min="0.25" max="4" step="0.25" value="1" style="flex:1">
        <div id="speedVal" class="muted">1x</div>
      </div>
    </div>

    <div class="panel">
      <div class="muted">Commander Abilities</div>
      <div style="margin-top:8px" class="ability">
        <div style="flex:1">
          <div class="muted">Hoang Thai Son (Red)</div>
          <div style="display:flex;gap:8px;margin-top:6px">
            <button id="precisionBtn">Precision Strike</button>
            <button id="reinforceBtn">Tactical Reinforce</button>
            <button id="chalkstormBtn">Chalkstorm</button>
          </div>
        </div>
      </div>
      <div style="margin-top:10px" class="ability">
        <div style="flex:1">
          <div class="muted">Hoang Thu Trang (Blue)</div>
          <div style="display:flex;gap:8px;margin-top:6px">
            <button id="mirrorBtn">Mirror Veil</button>
            <button id="shadowBtn">Shadow Draw</button>
            <button id="collapseBtn">Illusion Collapse</button>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="muted">Options</div>
      <label class="muted"><input type="checkbox" id="showParticles" checked> Show particles</label><br>
      <label class="muted"><input type="checkbox" id="showNames"> Show commander names</label>
    </div>

    <div class="footer">This is a browser-only simulator. Designed for performance: squads are simulated as many small agents. Use the ability buttons to influence the battle.</div>
  </div>

  <div id="center">
    <canvas id="c" width="1200" height="720"></canvas>
    <div style="margin-top:8px;color:var(--muted);font-size:13px">Tip: Precision Strike is devastating vs grouped units. Mirror Veil temporarily increases effective blue numbers.</div>
  </div>
</div>

<script>
/* Chalk Warfare 3 — 1000 vs 1000 Auto-battle Simulator
   Single-file, no dependencies. Focus on performance and clear visuals.
*/
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// UI
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const redAliveEl = document.getElementById('redAlive');
const blueAliveEl = document.getElementById('blueAlive');
const timeEl = document.getElementById('time');
const redKillsEl = document.getElementById('redKills');
const blueKillsEl = document.getElementById('blueKills');
const precisionBtn = document.getElementById('precisionBtn');
const reinforceBtn = document.getElementById('reinforceBtn');
const chalkstormBtn = document.getElementById('chalkstormBtn');
const mirrorBtn = document.getElementById('mirrorBtn');
const shadowBtn = document.getElementById('shadowBtn');
const collapseBtn = document.getElementById('collapseBtn');
const showParticles = document.getElementById('showParticles');

let simSpeed = 1;
let running = false;
let simTime = 0; // seconds

// Simulation parameters
const RED_COUNT = 1000;
const BLUE_COUNT = 1000;
const MAX_UNITS = RED_COUNT + BLUE_COUNT;

// Unit arrays — small agents
let units = []; // {id,team,x,y,hp,atk,rate,alive,ttl,cloned}
let projectiles = []; // lightweight
let particles = [];

let stats = {redKills:0, blueKills:0};

// Ability cooldowns (seconds)
let cooldowns = {
  precision: 0, reinforce: 0, chalkstorm: 0,
  mirror: 0, shadow: 0, collapse: 0
};

// Ability active timers
let actives = {precision:0,reinforce:0,chalkstorm:0,mirror:0,shadow:0,collapse:0};

function resetSim(){
  units = [];
  projectiles = [];
  particles = [];
  stats = {redKills:0, blueKills:0};
  simTime = 0;
  for(let i=0;i<RED_COUNT;i++){
    units.push({id:units.length,team:'red',x:50+Math.random()*220,y:50+Math.random()*(H-100),hp:1,atk:0.15,rate:0.6,alive:true,cloned:false});
  }
  for(let i=0;i<BLUE_COUNT;i++){
    units.push({id:units.length,team:'blue',x:W-50-Math.random()*220,y:50+Math.random()*(H-100),hp:1,atk:0.12,rate:0.6,alive:true,cloned:false});
  }
  // reset cooldowns
  for(let k in cooldowns) cooldowns[k]=0;
  for(let k in actives) actives[k]=0;
  updateStats();
}

// Basic helper
function rand(min,max){return Math.random()*(max-min)+min}

// Abilities implementations
function usePrecision(){ if(cooldowns.precision>0) return; cooldowns.precision=20; actives.precision=0.7; // short but powerful
  // immediate area damage to many blue units: we'll mark many blues as killed probabilistically
  // but to keep visuals, spawn projectiles sweeping from red side
  for(let i=0;i<200;i++){
    projectiles.push({x:100+Math.random()*200,y:rand(60,H-60),vx:6+Math.random()*2,vy:0,team:'red',damage:1,ttl:1});
  }
}
function useReinforce(){ if(cooldowns.reinforce>0) return; cooldowns.reinforce=30; actives.reinforce=6; // resurrect small portion over time
}
function useChalkstorm(){ if(cooldowns.chalkstorm>0) return; cooldowns.chalkstorm=25; actives.chalkstorm=8; }
function useMirror(){ if(cooldowns.mirror>0) return; cooldowns.mirror=25; actives.mirror=6; // temporarily double blue effective
  // spawn cloned agents (flag cloned=true so kills count differently)
  let blues = units.filter(u=>u.team==='blue' && u.alive && !u.cloned);
  const cloneCount = Math.min(500, Math.floor(blues.length*0.6));
  for(let i=0;i<cloneCount;i++){
    let b = blues[i%blues.length];
    if(!b) break;
    let c = {id:units.length,team:'blue',x:b.x+rand(-8,8),y:b.y+rand(-8,8),hp:1,atk:b.atk,rate:b.rate,alive:true,cloned:true,ttl:6};
    units.push(c);
  }
}
function useShadow(){ if(cooldowns.shadow>0) return; cooldowns.shadow=28; actives.shadow=5; }
function useCollapse(){ if(cooldowns.collapse>0) return; cooldowns.collapse=20; actives.collapse=0.8; // surprise heavy strike
  // create confusion: large random damages on both sides but more to reds
  for(let i=0;i<100;i++){
    projectiles.push({x:rand(200,W-200),y:rand(80,H-80),vx:0,vy:0,team:'neutral',damage: Math.random()<0.6?1:0,ttl:0.6});
  }
}

// Attach UI
startBtn.onclick = ()=>{ running=true; };
pauseBtn.onclick = ()=>{ running=false; };
resetBtn.onclick = ()=>{ running=false; resetSim(); };
speedRange.oninput = ()=>{ simSpeed = parseFloat(speedRange.value); speedVal.textContent = simSpeed+'x'; };
precisionBtn.onclick = usePrecision; reinforceBtn.onclick = useReinforce; chalkstormBtn.onclick = useChalkstorm;
mirrorBtn.onclick = useMirror; shadowBtn.onclick = useShadow; collapseBtn.onclick = useCollapse;

// Core simulation step (optimized)
let last = performance.now();
function step(now){
  const dt = Math.min(60, now-last)/1000; last = now;
  if(running) simTime += dt * simSpeed;
  const simDt = dt * simSpeed;

  // cooldown reductions
  for(let k in cooldowns) cooldowns[k]=Math.max(0,cooldowns[k]-simDt);
  for(let k in actives) actives[k]=Math.max(0,actives[k]-simDt);

  if(running){
    // units decide actions: for perf, pick some random pairs to engage each tick
    // calculate living arrays
    const reds = units.filter(u=>u.alive && u.team==='red');
    const blues = units.filter(u=>u.alive && u.team==='blue');

    // handle reinforce: slowly resurrect a few reds if reinforce active
    if(actives.reinforce>0){
      for(let i=0;i<3;i++){
        // find dead red slots to resurrect as new agents near spawn
        const deadIndex = units.findIndex(u=>!u.alive && u.team==='red' && !u.cloned);
        if(deadIndex>=0){ units[deadIndex].alive=true; units[deadIndex].hp=1; units[deadIndex].x=50+rand(0,220); units[deadIndex].y=50+rand(0,H-100); }
      }
    }

    // interactions: sample engagement attempts to avoid O(n^2)
    const SAMPLES = 700; // scale for intensity
    for(let s=0;s<SAMPLES;s++){
      // pick random attacker
      const idx = Math.floor(Math.random()*units.length);
      const a = units[idx];
      if(!a || !a.alive) continue;
      // find target from opposite side via random pick biased by alive counts
      let targetPool = (a.team==='red')?blues:reds; if(targetPool.length===0) break;
      const t = targetPool[Math.floor(Math.random()*targetPool.length)];
      // hit chance influenced by skill, actives
      let hitChance = 0.2 + (a.team==='red'?0.05:0); // slight red accuracy
      if(actives.precision>0 && a.team==='red') hitChance += 0.25;
      if(actives.shadow>0 && a.team==='blue') hitChance -= 0.15; // blue hard to hit when shadow active
      if(actives.mirror>0 && t.cloned) hitChance += 0.1; // clones easier to hit visually
      if(Math.random()<hitChance * a.atk){
        // target dies
        t.alive = false;
        if(a.team==='red') stats.redKills++; else stats.blueKills++;
        particles.push({x:t.x,y:t.y,ttl:0.6,col:(a.team==='red'?'#ff7b7b':'#9fd1ff')});
      }
    }

    // projectiles movement (visual only)
    for(let i=projectiles.length-1;i>=0;i--){
      const p = projectiles[i]; p.x += (p.vx||0)*simDt*60; p.y += (p.vy||0)*simDt*60; p.ttl -= simDt; if(p.ttl<=0) projectiles.splice(i,1);
      // some projectiles instantly kill in area
      if(p.damage>0 && p.ttl>0 && p.team==='red'){
        // small area sweep, kill nearby blues
        const kills = units.filter(u=>u.alive && u.team==='blue' && Math.hypot(u.x-p.x,u.y-p.y)<18);
        kills.forEach(k=>{ k.alive=false; stats.redKills++; particles.push({x:k.x,y:k.y,ttl:0.5,col:'#ffbdbd'}); });
      }
    }

    // particles
    for(let i=particles.length-1;i>=0;i--){ particles[i].ttl -= simDt; if(particles[i].ttl<=0) particles.splice(i,1); }

    // cleanup cloned TTLs
    for(let u of units){ if(u.cloned){ u.ttl -= simDt; if(u.ttl<=0){ u.alive = false; } } }

    // random small movement for visuals
    for(let u of units){ if(u.alive){ u.x += rand(-6,6)*simDt; u.y += rand(-6,6)*simDt; u.x = Math.max(40, Math.min(W-40, u.x)); u.y = Math.max(40, Math.min(H-40, u.y)); } }
  }

  // update HUD
  updateStats();
  render();
  requestAnimationFrame(step);
}

function updateStats(){
  const redAlive = units.filter(u=>u.alive && u.team==='red').length;
  const blueAlive = units.filter(u=>u.alive && u.team==='blue').length;
  redAliveEl.textContent = redAlive;
  blueAliveEl.textContent = blueAlive;
  redKillsEl.textContent = stats.redKills;
  blueKillsEl.textContent = stats.blueKills;
  // time
  const mm = Math.floor(simTime/60).toString().padStart(2,'0');
  const ss = Math.floor(simTime%60).toString().padStart(2,'0');
  timeEl.textContent = mm + ':' + ss;
}

function render(){
  ctx.clearRect(0,0,W,H);
  // background
  const grd = ctx.createLinearGradient(0,0,0,H); grd.addColorStop(0,'#05202b'); grd.addColorStop(1,'#03151d'); ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);

  // draw spawn zones
  ctx.fillStyle='rgba(255,100,100,0.04)'; ctx.fillRect(0,30,280,H-60);
  ctx.fillStyle='rgba(100,160,255,0.03)'; ctx.fillRect(W-280,30,280,H-60);

  // draw midline
  ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.beginPath(); ctx.moveTo(W/2,20); ctx.lineTo(W/2,H-20); ctx.stroke();

  // chalkstorm effect
  if(actives.chalkstorm>0){ ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fillRect(0,0,W,H); }

  // units (draw aggregated clusters for performance if too many alive)
  const aliveUnits = units.filter(u=>u.alive);
  if(aliveUnits.length>800){
    // draw as small dots with alpha to avoid heavy drawing
    for(let u of aliveUnits){ ctx.fillStyle = u.team==='red' ? 'rgba(255,100,100,0.9)' : 'rgba(140,200,255,0.95)'; ctx.fillRect(u.x-1,u.y-1,2,2); }
  } else {
    for(let u of aliveUnits){ ctx.beginPath(); ctx.fillStyle = u.team==='red' ? '#ff8080' : '#9fd1ff'; ctx.arc(u.x,u.y,3,0,Math.PI*2); ctx.fill(); }
  }

  // projectiles
  if(showParticles.checked){
    for(let p of projectiles){ ctx.beginPath(); ctx.fillStyle = p.team==='red'? '#ffbdbd':'#bfe1ff'; ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); }
    for(let pt of particles){ ctx.beginPath(); ctx.fillStyle = pt.col; ctx.arc(pt.x,pt.y,10*(pt.ttl/0.6),0,Math.PI*2); ctx.fill(); }
  }

  // commander overlays
  if(document.getElementById('showNames').checked){ ctx.fillStyle='#ffb3b3'; ctx.font='18px sans-serif'; ctx.fillText('Hoang Thai Son (Red)', 40,30); ctx.fillStyle='#bfe6ff'; ctx.fillText('Hoang Thu Trang (Blue)', W-360,30); }

  // draw HUD mini counts on field
  ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(W/2-110,H-50,220,36);
  ctx.fillStyle='#ff7b7b'; ctx.font='18px sans-serif'; ctx.fillText(units.filter(u=>u.alive && u.team==='red').length, W/2-50, H-26);
  ctx.fillStyle='#9fd1ff'; ctx.fillText(units.filter(u=>u.alive && u.team==='blue').length, W/2+20, H-26);
}

// initialize
resetSim();
requestAnimationFrame(step);

</script>
</body>
</html>
